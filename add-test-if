import { render, screen, fireEvent, act, waitFor } from '@testing-library/react';
import AddPayee from './AddPayee'; // Adjust the import path based on your project

// Mocks for your API calls
jest.mock('path-to-your-api', () => ({
  post: jest.fn(),
}));

// Test case
it("should trigger API call when conditions in handleBlur are met", async () => {
  // Mock implementation for `post` API call
  const mockPost = require('path-to-your-api').post;
  mockPost.mockResolvedValue({ success: true });

  // Step 1: Render the component
  await act(async () => render(<AddPayee />));

  // Step 2: Set up the conditions for the `if` statement to evaluate as true.
  const payeeAccNo = '1234567890'; // Some valid account number
  const ibanFocusValue = '0987654321'; // Different from `payeeAccNo` to satisfy the condition
  const payeeAccNoErrorMessage = ''; // Error message should be falsy (empty string)
  const beneErrorStatus = false; // Should also work, as the condition checks for `payeeAccNo !== ibanFocusValue`

  // Set state to simulate the conditions (use fireEvent or act to simulate user interactions)

  // Get the payee account number input element (adjust selector as needed)
  const payeeAccNoInput = screen.getByTestId('iban-input');
  
  // Simulate user entering the account number
  fireEvent.change(payeeAccNoInput, { target: { value: payeeAccNo } });

  // Simulate the blur event on the input field
  fireEvent.blur(payeeAccNoInput);

  // Step 3: Wait for the API to be called
  await waitFor(() => {
    expect(mockPost).toHaveBeenCalledTimes(1); // Expect the API call to have been made once
  });

  // Step 4: Optionally, check if any loading indicator or result appears based on the response
  // Example: Check for a "Loading..." text or success message after the API call.
  expect(await screen.getByText('API Call Successful')).toBeInTheDocument(); // Adjust based on your actual success message
});
